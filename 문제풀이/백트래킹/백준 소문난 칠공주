# DFS 풀이 
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline


board = [list(input().strip()) for _ in range(5)]
visited = set()

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

answer = 0

# idx = x*5 + y (0~24)
# selected : 선택된 idx 리스트
def dfs(selected, ycnt):
    global answer
    
    # Y가 4명 이상이면 종료
    if ycnt >= 4:
        return
    
    # 7명이 선택되었을 때
    if len(selected) == 7:
        key = frozenset(selected)
        if key not in visited:
            visited.add(key)
            answer += 1
        return
    
    # 현재 선택된 칸 중 인접한 칸들 탐색
    for idx in list(selected):
        x,y = divmod(idx,5)
        for i in range(4):
            xx,yy = x+dx[i], y+dy[i]
            if 0<=xx<5 and 0<=yy<5:
                nidx = xx*5+ yy
                # 이미 선택했거나 번호가 더 작은 칸이면 스킵
                if nidx in selected or nidx < min(selected):
                    continue
                dfs(selected|{nidx}, ycnt + (board[xx][yy] == 'Y'))

# 모든 칸을 시작점으로 탐색    
for i in range(25):
    x,y = divmod(i,5)
    dfs({i}, board[x][y] == 'Y')
    
print(answer)


#BFS + 조합 풀이
from collections import deque
from itertools import combinations


board = [list(input().strip()) for _ in range(5)]

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

answer = 0

# 연결성 확인 
def is_connected(selected):
    queue = deque([selected[0]])
    visited = {selected[0]}
    
    while queue:
        idx = queue.popleft()
        x,y = divmod(idx,5)
        
        for i in range(4):
            xx,yy = x+dx[i], y+ dy[i]
            nidx = xx*5 + yy
            if 0<=xx<5 and 0<=yy<5:
                if nidx in selected and nidx not in visited:
                    visited.add(nidx)
                    queue.append(nidx)   
                    
    return len(visited) == 7 # 7칸 모두 연결되어 있으면 True

# 조합 
for comb in combinations(range(25),7):
    s_count = sum( 1 for idx in comb if board[idx//5][idx%5] == 'S' )
    
    if s_count < 4:
        continue

    # 연결되어 있으면 카운트 증가
    if is_connected(comb):
        answer +=1

print(answer)
